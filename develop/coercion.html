<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.6 at 2017-06-20 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PostgreSQL PL/Java &#x2013; Passing of data types between PostgreSQL and Java</title>
    <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style>
    <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20170620" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                        <a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean">
                                                <img src="../images/pljava_logo.jpg" alt="PL/Java logo combining the PostgreSQL elephant and a Java bean" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2017-06-20</span>
                  &nbsp;| <span id="projectVersion">Version: 1.5.1-BETA1</span>
                      </div>
            <div class="xright">                    <a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a>
            |
                        <a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a>
            |
                        <a href="http://lists.pgfoundry.org/pipermail/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a>
            |
                        <a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>Usage</h5>
                  <ul>
                  <li class="none">
                          <a href="../build/build.html" title="Building PL/Java">Building PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a>
            </li>
                  <li class="none">
                          <a href="../install/upgrade.html" title="Upgrading">Upgrading</a>
            </li>
                  <li class="none">
                          <a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../use/use.html" title="User guide">User guide</a>
            </li>
                  <li class="none">
                          <a href="../develop/develop.html" title="Developer notes">Developer notes</a>
            </li>
          </ul>
                       <h5>Release Information</h5>
                  <ul>
                  <li class="none">
                          <a href="../releasenotes.html" title="Release notes">Release notes</a>
            </li>
          </ul>
                       <h5>Modules</h5>
                  <ul>
                  <li class="none">
                          <a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a>
            </li>
                  <li class="none">
                          <a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-deploy/index.html" title="PL/Java Deploy">PL/Java Deploy</a>
            </li>
                  <li class="none">
                          <a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a>
            </li>
                  <li class="none">
                          <a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a>
            </li>
                  <li class="none">
                          <a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="../project-info.html" title="Project Information">Project Information</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <h1>Passing of data types between PostgreSQL and Java</h1>
<p>The wiki documentation for <a class="externalLink" href="https://github.com/tada/pljava/wiki/Default-type-mapping">default type mapping</a> gives a rather high-level view. That seems adequate for most uses (the archives are not full of &#x201c;why on earth did PL/Java do that to my data type?&#x201d; questions), but this page is meant to capture the steps in more detail.</p>
<div class="section">
<h2><a name="Some_preliminaries"></a>Some preliminaries</h2>
<div class="section">
<h3><a name="The_per-schema_class_path"></a>The per-schema class path</h3>
<p>One of the most significant differences between the ISO 9075-13 standard and what PL/Java actually does is in the area of finding and loading classes. In the standard, when a function is declared in SQL, its <tt>external Java reference string</tt> (corresponding to the <tt>AS</tt> clause in PostgreSQL) <i>names the installed jar</i> where the search for the class should begin. The standard also provides an <tt>SQLJ.ALTER_JAVA_PATH</tt> function that gives complete control, based on the jar where a search begins, of which other jars should be searched for dependencies.</p>
<p>By contrast, PL/Java (through and including 1.5) <i>does not</i> include the jar name in <tt>AS</tt> clauses, and provides an <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#setClassPathjava.lang.String20java.lang.String"><tt>SQLJ.SET_CLASSPATH</tt></a> function that can set a distinct class path for any schema in the database. The schema <tt>public</tt> can also have a class path, which becomes the fallback for any search that is not resolved on another schema&#x2019;s class path.</p>
<p>The class named in an SQL function declaration&#x2019;s <tt>AS</tt> clause is looked up on the <i>class path for the schema in which the function is declared</i>, with the <tt>public</tt> schema as fallback.</p></div>
<div class="section">
<h3><a name="The_per-schema_type_map"></a>The per-schema type map</h3>
<p>When PL/Java is used to create user-defined types, there needs to be a way of associating the type name declared in SQL with the Java class that implements it. The most transparent case is a <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">base type</a> (written in PL/Java with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/BaseUDT.html">@BaseUDT annotation</a>), which is completely integrated into PostgreSQL&#x2019;s type system and is usable from in or out of Java just like any other PostgreSQL type.</p>
<p>For the other flavors of user-defined type (described below), <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#addTypeMappingjava.lang.String20java.lang.String"><tt>SQLJ.ADD_TYPE_MAPPING</tt></a> (a PL/Java function, not in the standard) must be called to record the connection between the new type&#x2019;s SQL name and the Java class that implements it. The <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT annotation</a> generates a call to this function along with any other SQL commands declaring the type.</p>
<p>What it records is simply the SQL type name as a string, and the Java class name as a string, and these mappings apply database-wide. But internally, PL/Java maintains a type map per schema. Why? (Hint: while it is true that the SQL type names can be schema-qualified, that is not the answer.)</p>
<p>The reason is that the database-wide mappings are from SQL type names to Java class <i>names</i>, and the actual Java class found for a given name can depend on the per-schema class path.</p>
<p>Whenever the rules given below provide for applying the type map, they mean, for parameter and return value conversions done at the invocation of a PL/Java function, the type map for the schema in which the target function is declared and, at other times, the map for the schema in which the innermost executing PL/Java function on the call stack is declared.</p></div>
<div class="section">
<h3><a name="PLJavas_object_system_implemented_in_C"></a>PL/Java&#x2019;s object system implemented in C</h3>
<p>In PL/Java, some behavior is implemented in Java using familiar Java objects, and some is implemented in C with an object-oriented approach using C <tt>struct</tt>s that include and extend each other for &#x2018;classes&#x2019; and their instances, forming a C object hierarchy that inherits ultimately from <tt>PgObject</tt>. Often there is a close relationship between a C &#x2018;class&#x2019; and a Java class of the same name, with instances of one holding references to the other.</p>
<p>The <tt>type</tt> subdirectory in <tt>pljava-so</tt> contains the C sources for a class <tt>Type</tt>, which inherits directly from <tt>PgObject</tt>, and many subclasses of <tt>Type</tt> representing different known SQL types and how they correspond to Java types.</p>
<p>Each C <tt>Type</tt> has a method <tt>coerceDatum</tt> that takes a PostgreSQL <tt>Datum</tt> and produces the corresponding Java value, and a method <tt>coerceObject</tt> that does the reverse. There are also <tt>invoke*</tt> methods provided on <tt>Type</tt>. The convention is that the actual invocation of a function goes through the subclass of <tt>Type</tt> that represents the function&#x2019;s return type.</p></div></div>
<div class="section">
<h2><a name="When_type_coercions_can_take_place"></a>When type coercions can take place</h2>
<p>SQL types can be converted to Java objects or the reverse in several different contexts.</p>
<div class="section">
<h3><a name="Parameters_and_return_values_when_calling_a_PLJava_function_from_SQL"></a>Parameters and return values when calling a PL/Java function from SQL</h3>
<p>These are the usual rules for converting function parameters from the types used in the function&#x2019;s SQL declaration to the types of the underlying Java method&#x2019;s signature, and the Java method&#x2019;s return type to the return type in the SQL declaration. They do not apply to the special cases where a composite type is passed or returned, which are seen by the Java code as JDBC result sets.</p>

<ol style="list-style-type: decimal">
  
<li>
<p>A C <tt>Type</tt> subclass is looked up for the SQL type name declared for the parameter or return type, using the fixed mappings registered during PL/Java initialization (see calls to <tt>Type_registerType</tt> in the code).</p></li>
  
<li>
<p>If this search has not produced a <tt>Type</tt> (after forming an array type where necessary, or replacing a domain with its base type), the type map is consulted, which may result in a new <tt>UDT</tt> subclass being registered that handles the conversion between a PostgreSQL <tt>Datum</tt> and the associated Java class.</p></li>
  
<li>
<p><i>If the function&#x2019;s <tt>AS</tt> clause only names a method, without parameter or return type signatures,</i> the Java types that correspond to the <tt>Type</tt> objects chosen at this stage are used to construct a signature for the Java method. The method to be used must have the given name and exact signature, or one replacing a primitive return type with its boxed form, or one with <tt>ResultSetProvider</tt> replaced with <tt>ResultSetHandle</tt>. Either the matching method is found at this step, or the call fails.</p></li>
  
<li>
<p><i>If the function&#x2019;s <tt>AS</tt> clause includes Java types for the parameters and/or return type,</i> they are compared (textually) to the signature that would have been generated. If they all match, the method is resolved in the same way as if the signature had not been included.</p></li>
  
<li>
<p>For any Java type in the explicit method signature that differs from the the one that corresponds to the C <tt>Type</tt> subclass so far chosen, another C <tt>Type</tt> is looked up using the explicit Java type as the key. If that <tt>Type</tt> is usable in place of the one earlier chosen (as determined by the <tt>Type_canReplaceType</tt> method), it will be used. Otherwise, a <tt>Coerce</tt> type is generated according to PostgreSQL&#x2019;s <tt>find_coercion_pathway</tt> function, which uses all of PostgreSQL&#x2019;s configured type-casting rules to find a suitable conversion.</p></li>
</ol>
<p>That final step is roughly equivalent to inserting an SQL <tt>CAST</tt>. However, two of PostgreSQL&#x2019;s possible casting strategies are not currently handled by PL/Java, namely array coercions, and coercions by going through the text output/input functions. Also, if the return type in the SQL declaration is a domain, constraints on the domain are not checked, allowing the function to return values of the base type that should not be possible in the domain. This is a bug.</p></div>
<div class="section">
<h3><a name="Parameters_supplied_to_a_JDBC_PreparedStatement_from_Java"></a>Parameters supplied to a JDBC <tt>PreparedStatement</tt> from Java</h3>
<p>These are passed through the <tt>coerceObject</tt> method of a C <tt>Type</tt> selected according to the SQL type that the query plan has for the parameter. The type map for the innermost PL/Java invocation on the call stack is consulted if necessary, so these rules are equivalent to the first two in the &#x201c;parameters and return values&#x201d; case. However, see &#x201c;additional JDBC coercions&#x201d; below.</p>
<p>JDBC defines some <tt>setObject</tt> and <tt>setNull</tt> methods on <tt>PreparedStatement</tt> that must be passed a <tt>java.sql.Types</tt> constant. The JDBC constant will be mapped to a PostgreSQL type OID through a fixed mapping coded in <tt>Oid_forSqlType</tt>.</p></div>
<div class="section">
<h3><a name="Values_read_or_written_through_the_JDBC_ResultSet_interface"></a>Values read or written through the JDBC <tt>ResultSet</tt> interface</h3>
<p>This case includes not only results from SPI queries made in Java, but also composite function parameters or return values, and <i>old</i> and <i>new</i> tuples in triggers.</p>
<p>Although done in different places in the code (<tt>SPIResultSet</tt>, <tt>Tuple</tt>, <tt>HeapTupleHeader</tt>, <tt>TupleDesc</tt>), these also have the same behavior as the first two rules in the &#x201c;parameters and return values&#x201d; case. Again, see &#x201c;additional JDBC coercions&#x201d; below.</p></div>
<div class="section">
<h3><a name="Values_read_or_written_through_the_JDBC_SQLInputSQLOutput_interfaces"></a>Values read or written through the JDBC <tt>SQLInput</tt>/<tt>SQLOutput</tt> interfaces</h3>
<p>These are used in PL/Java&#x2019;s implementation of user-defined types. There are three distinct flavors of user-defined type that PL/Java can manage. <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">Base types</a> and <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249">composite types</a> are established terms in PostgreSQL. <i>Mirrored type</i> is a term invented just now to denote that other thing PL/Java can do.</p>

<dl>
<dt><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">Base type</a> a/k/a scalar type</dt>
<dd>A type declared with the <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">no-<tt>AS</tt> form of <tt>CREATE TYPE</tt></a>, integrating into the PostgreSQL type system at the lowest level. The implementation controls its stored size and format and its text input and output syntax. The fact that the type is implemented in Java is transparent and it can be used from SQL like any other type. For access to the storage area, Java code is provided <tt>SQLInput</tt> and <tt>SQLOutput</tt> implementations that act as raw memory buffer accessors with methods to read and write common types of various widths. Created by a Java class with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/BaseUDT.html">@BaseUDT</a> annotation.</dd>
<dt><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249">Composite type</a></dt>
<dd>A type declared with the <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249"><tt>AS</tt> (list of named typed attributes) form of <tt>CREATE TYPE</tt></a>, which can then be associated with a Java class using <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#addTypeMappingjava.lang.String20java.lang.String">SQLJ.ADD_TYPE_MAPPING</a>. From outside of Java code, it can be manipulated like any PostgreSQL composite type, while to Java code it will be presented as an instance of the associated Java class&#x2013;a new instance at every conversion, however. Java code is provided <tt>SQLInput</tt> and <tt>SQLOutput</tt> implementations that retrieve and set the typed attributes of the composite. Created by a Java class with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT</a> annotation having a <tt>structure</tt> attribute.</dd>
<dt>Mirrored type</dt>
<dd>An existing PostgreSQL type that is outside of the standard SQL types that have pre-registered PL/Java <tt>Type</tt> mappings, but has been associated with a Java class through use of <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#addTypeMappingjava.lang.String20java.lang.String">SQLJ.ADD_TYPE_MAPPING</a>. The Java code is provided the same raw-memory-accessing <tt>SQLInput</tt> and <tt>SQLOutput</tt> implementations as for a base type, and the developer must understand and match the stored form of the existing type. This can be a brittle design to maintain. Because PL/Java consults the type map only if the first step of <tt>Type</tt> lookup fails, standard SQL types like <tt>integer</tt> cannot be mirrored this way. Created by a Java class with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT</a> annotation having no <tt>structure</tt> attribute, and naming an existing PostgreSQL type.</dd>
</dl>
<p><i>Note: the presence of absence of a <tt>structure</tt> attribute in a <tt>@MappedUDT</tt> annotation only determines whether the SQL generator emits a <tt>CREATE TYPE</tt> declaring the structure, as well as the <tt>SQLJ.ADD_TYPE_MAPPING</tt> call (which is always emitted) to associate the class. The <tt>@MappedUDT</tt> annotation could also be used with no <tt>structure</tt> attribute and the name of an existing composite type, to associate that type with a Java class. This would act as a composite type (with <tt>SQLInput</tt>/<tt>SQLOutput</tt> working in typed-tuple mode), even though it could also be described as mirroring an existing type.</i></p>

<table border="0" class="bodyTable"><caption>Summary</caption>
  <thead>
    
<tr class="a">
      
<th> </th>
      
<th align="center"><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">Base type</a> </th>
      
<th align="center"><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249">Composite type</a> </th>
      
<th align="center">Mirrored type </th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><b>Annotate</b> </td>
      
<td align="center"><a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/BaseUDT.html">@BaseUDT</a> </td>
      
<td align="center" colspan="2"><a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT</a> </td>
    </tr>
    
<tr class="a">
      
<td><b>Stored form</b> </td>
      
<td align="center">Raw (Java controls) </td>
      
<td align="center">Tuple </td>
      
<td align="center">Native (Java must match) </td>
    </tr>
    
<tr class="b">
      
<td><b>SQLInput/SQLOutput mode</b> </td>
      
<td align="center">Raw buffer </td>
      
<td align="center">Typed tuple </td>
      
<td align="center">Raw buffer </td>
    </tr>
  </tbody>
  
</table>
<div class="section">
<h4><a name="SQLInputSQLOutput_in_typed_tuple_mode"></a><tt>SQLInput</tt>/<tt>SQLOutput</tt> in typed tuple mode</h4>
<p>In this mode, values read or written through this interface get the same treatment they would from a JDBC <tt>ResultSet</tt>, converted according to the first two rules set out above.</p></div>
<div class="section">
<h4><a name="SQLInputSQLOutput_in_raw_memory_access_mode"></a><tt>SQLInput</tt>/<tt>SQLOutput</tt> in raw memory access mode</h4>
<p>In this mode, SQL-specific conversions are not performed, and many of the SQL-specific <tt>read...</tt> and <tt>write...</tt> methods are disabled (throwing an exception for unsupported operation), leaving mostly those for common Java types with familiar widths and formats. The <tt>wasNull</tt> method always returns <tt>false</tt>. The methods for <tt>Byte</tt>, <tt>Short</tt>, <tt>Int</tt>, and <tt>Long</tt> deal directly in 1, 2, 4, or 8-octet fields, as with the methods for other fixed-width types. The methods for variable-length fields (<tt>BigDecimal</tt>, <tt>BinaryStream</tt>, <tt>Bytes</tt>, <tt>CharacterStream</tt>, <tt>String</tt>, and <tt>URL</tt>) all share a 16-bit-length-prefixed format allowing up to 65535 bytes in the field.</p>

<table border="0" class="bodyTable"><caption>Formats used by <tt>SQLInput</tt>/<tt>SQLOutput</tt> in raw mode. <tt>pfx</tt> is variable length with 2-octet count.</caption>
  <thead>
    
<tr class="a">
      
<th align="right"><tt>read</tt>/<tt>write...</tt> method </th>
      
<th align="center">acts on </th>
      
<th align="left">notes </th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td align="right"><tt>Array</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>AsciiStream</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>BigDecimal</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">as via *<tt>String</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>BinaryStream</tt> </td>
      
<td align="center">pfx </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Blob</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Boolean</tt> </td>
      
<td align="center">1 octet </td>
      
<td align="left"><tt>!= 0</tt>, written as <tt>1</tt> or <tt>0</tt></td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Byte</tt> </td>
      
<td align="center">1 octet </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Bytes</tt> </td>
      
<td align="center">pfx </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>CharacterStream</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">as via *<tt>String</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Clob</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Date</tt> </td>
      
<td align="center">8 octets </td>
      
<td align="left"><tt>getTime()</tt> as <tt>long</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Double</tt> </td>
      
<td align="center">8 octets </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Float</tt> </td>
      
<td align="center">4 octets </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Int</tt> </td>
      
<td align="center">4 octets </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Long</tt> </td>
      
<td align="center">8 octets </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>NClob</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>NString</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Object</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Ref</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>RowId</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Short</tt> </td>
      
<td align="center">2 octets </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>SQLXML</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>String</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">always <tt>UTF-8</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Struct</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Time</tt> </td>
      
<td align="center">8 octets </td>
      
<td align="left"><tt>getTime()</tt> as <tt>long</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Timestamp</tt> </td>
      
<td align="center">8 octets </td>
      
<td align="left"><tt>getTime()</tt> as <tt>long</tt></td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>URL</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">via *<tt>String</tt></td>
    </tr>
  </tbody>
  
</table>
<p><i>Note: in all PL/Java versions to and including <tt>1.5.0-BETA2</tt>, the <tt>SQLInput</tt>/<tt>SQLOutput</tt> methods for types wider than a byte are bigendian, regardless of the underlying hardware.</i></p>
<p>For mirrored types, this is plainly a bug: when running on little-endian hardware, PostgreSQL and Java will disagree on what the values are.</p>
<p>For base types there is no disagreement issue (because <i>only</i> the Java code manipulates those), though there may be a slight performance cost. In release 1.5.0, byte order is selectable. For mirrored types, the default has changed to <tt>native</tt>. For base types, the default stays <tt>big_endian</tt>, to preserve the values of any existing user-defined types stored with earlier PL/Java versions, and to preserve their <tt>COPY</tt> and on-network binary form.</p>
<p>Because of the &#x201c;UDT function slot switcheroo&#x201d; (described further below), PL/Java UDTs implicitly have a binary send/receive/<tt>COPY</tt> form reflecting their internal stored representation; they cannot, at present, use the send and receive function slots to define a custom format for binary transfer. Because the <a class="externalLink" href="http://www.postgresql.org/docs/8.2/static/sql-copy.html#AEN46503">binary <tt>COPY</tt> format documentation</a> specifies network byte order (that is, big-endian), there are no plans to change the default stored form from <tt>big_endian</tt> until some future release decouples the stored representation from that for binary transfer.</p>
<p>In some future upgrade, it may be appropriate to change the byte order for base types, which will require a migration step for any stored data of PL/Java base types. Methods for doing that are covered on the <a href="../use/byteorder.html">byte order page</a>.</p></div></div></div>
<div class="section">
<h2><a name="Additional_JDBC_coercions"></a>Additional JDBC coercions</h2>
<p>When reading or writing values through any of the JDBC interfaces (except <tt>SQLInput</tt>/<tt>SQLOutput</tt> in raw mode), there is another layer of type coercion that can be applied, after (when reading) or before (when writing) the rules presented above, and unrelated to them. These are implemented entirely in Java, and can be found in <tt>SPIConnection.java</tt> under the names <tt>basicCoersion</tt>, <tt>basicNumericCoersion</tt>, and <tt>basicCalendricalCoersion</tt>.</p>
<p>The JDBC standard facilities for managing a type map are not implemented or used, and <tt>getTypeMap</tt> will always return <tt>null</tt>. All of PL/Java&#x2019;s uses of the type map managed with <tt>SQLJ.ADD_TYPE_MAPPING</tt> take place below the level of the JDBC mechanisms.</p></div>
<div class="section">
<h2><a name="The_user-defined-type_function_slot_switcheroo"></a>The user-defined-type function slot switcheroo</h2>
<p>When a new base type is defined in PostgreSQL, the <tt>CREATE TYPE</tt> command can specify four functions that deal directly with the type representation: <tt>INPUT</tt> and <tt>OUTPUT</tt>, which convert between the internal representation and printable/parsable text form, and <tt>RECEIVE</tt> and <tt>SEND</tt>, normally used to offer another transfer format, more efficient than text, to pass over the channel between frontend and backend.</p>
<p>When a new base UDT is defined in PL/Java, the generated <tt>CREATE TYPE</tt> command fills those four function slots, but with functions whose <tt>AS</tt> strings do not directly name the Java methods to call. Instead, the strings have a special form identifying the Java class associated with the type, and the slot type, <tt>INPUT</tt>/<tt>OUTPUT</tt>/<tt>SEND</tt>/<tt>RECEIVE</tt>. When PostgreSQL calls these &#x201c;functions&#x201d;, the PL/Java runtime passes control appropriately; there are fixed names and signatures for the four methods that the associated class needs to implement.</p>
<p>The semantics of the four slots are slightly reinterpreted. <tt>INPUT</tt> and <tt>OUTPUT</tt> still implement the type&#x2019;s outward, textual form, but instead of converting between that form and the form PostgreSQL sees, they convert between the text form and an instance of the Java class (using the methods <tt>parse</tt> and <tt>toString</tt>, respectively).</p>
<p>It would be natural to expect that the other two slots, <tt>RECEIVE</tt> and <tt>SEND</tt>, correspond to the other two required Java methods, <tt>readSQL</tt> and <tt>writeSQL</tt>, but they do not exactly. The <tt>readSQL</tt> and <tt>writeSQL</tt> are actually called only from the coercion methods of <tt>UDT</tt> (in PL/Java&#x2019;s C &#x201c;object&#x201d; system, a subclass of <tt>Type</tt>) when PL/Java needs to convert between a Java class instance and the PostgreSQL stored type, <i>not</i> from <tt>Function</tt> when PostgreSQL has called through the <tt>RECEIVE</tt> or <tt>SEND</tt> slot in order to transport the value between backend and frontend. This is the type-function-slot switcheroo.</p>
<p>That repurposing of the <tt>RECEIVE</tt> and <tt>SEND</tt> slots does not leave a way to name special functions for binary transport to the frontend, so whenever PostgreSQL does call through those slots, PL/Java always does a raw binary transfer using the <tt>libpq</tt> API directly (for fixed-size representations), <tt>bytearecv</tt>/<tt>byteasend</tt> for <tt>varlena</tt> representations, or <tt>unknownrecv</tt>/<tt>unknownsend</tt> for C string representations.</p>
<p>A future version could revisit this limitation, and allow PL/Java UDTs to specify custom binary transfer formats also.</p></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2003&#x2013;2017
                        <a href="http://tada.se/eng/">Tada AB</a>.
            All rights reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
