<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.6 at 2018-09-10 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PostgreSQL PL/Java &#x2013; Working with XML</title>
    <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style>
    <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20180910" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                        <a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean">
                                                <img src="../images/pljava_logo.jpg" alt="PL/Java logo combining the PostgreSQL elephant and a Java bean" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2018-09-10</span>
                  &nbsp;| <span id="projectVersion">Version: 1.5.1-BETA2</span>
                      </div>
            <div class="xright">                    <a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a>
            |
                        <a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a>
            |
                        <a href="http://lists.pgfoundry.org/pipermail/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a>
            |
                        <a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>Usage</h5>
                  <ul>
                  <li class="none">
                          <a href="../build/build.html" title="Building PL/Java">Building PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a>
            </li>
                  <li class="none">
                          <a href="../install/upgrade.html" title="Upgrading">Upgrading</a>
            </li>
                  <li class="none">
                          <a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../use/use.html" title="User guide">User guide</a>
            </li>
                  <li class="none">
                          <a href="../develop/develop.html" title="Developer notes">Developer notes</a>
            </li>
          </ul>
                       <h5>Release Information</h5>
                  <ul>
                  <li class="none">
                          <a href="../releasenotes.html" title="Release notes">Release notes</a>
            </li>
          </ul>
                       <h5>Modules</h5>
                  <ul>
                  <li class="none">
                          <a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a>
            </li>
                  <li class="none">
                          <a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-deploy/index.html" title="PL/Java Deploy">PL/Java Deploy</a>
            </li>
                  <li class="none">
                          <a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a>
            </li>
                  <li class="none">
                          <a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a>
            </li>
                  <li class="none">
                          <a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="../project-info.html" title="Project Information">Project Information</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <h1>Working with XML</h1>
<div class="section">
<h2><a name="In_PLJava_before_1.5.1"></a>In PL/Java before 1.5.1</h2>
<p>PL/Java functions before 1.5.1 have been able to access a value of XML type as a <tt>String</tt> object. That has been workable, but an extra burden if porting code that used the JDBC 4.0 <tt>java.sql.SQLXML</tt> API, and with notable shortcomings.</p>
<div class="section">
<h3><a name="Shortcomings"></a>Shortcomings</h3>
<div class="section">
<h4><a name="Character_set_encoding"></a>Character set encoding</h4>
<p>PostgreSQL stores XML values serialized according to <tt>server_encoding</tt>, and depending on that setting, conversion to a Java <tt>String</tt> can involve transcoding.</p>
<p>XML has rules to handle characters that may be representable in one encoding but not another, but the <tt>String</tt> conversion is unaware of them, and may fail to produce a transcoding that represents the same XML value.</p></div>
<div class="section">
<h4><a name="Memory_footprint"></a>Memory footprint</h4>
<p>While a database design using XML may be such that each XML datum is individually very small, it is also easy to store&#x2014;or generate in queries&#x2014;large XML values. When mapped to a Java <tt>String</tt>, such an XML value must have its full, uncompressed, character-serialized size allocated on the Java heap and be copied there from native memory, before the Java code even begins to make use of it. Even in cases where the Java processing to be done could be organized to stream through parse events in constant-bounded memory, the <tt>String</tt> representation forces the entire XML value to occupy Java memory at once. Any tuning of PL/Java&#x2019;s heap size allowance could have to consider a worst-case estimate of that size, or risk failures at run time.</p></div></div></div>
<div class="section">
<h2><a name="The_JDBC_4.0_java.sql.SQLXML_API"></a>The JDBC 4.0 <tt>java.sql.SQLXML</tt> API</h2>
<p>PL/Java 1.5.1 adds support for this API. A Java parameter or return type in a a PL/Java function can be declared to be <tt>SQLXML</tt>, and such objects can be retrieved from <tt>ResultSet</tt> and <tt>SQLInput</tt> objects, and used as <tt>PreparedStatement</tt> parameters or in <tt>SQLOutput</tt> and updatable <tt>ResultSet</tt> objects.</p>
<div class="section">
<h3><a name="Reading_a_PostgreSQL_XML_value_as_a_readable_SQLXML_object"></a>Reading a PostgreSQL XML value as a <i>readable</i> <tt>SQLXML</tt> object</h3>
<p>An <tt>SQLXML</tt> instance can have the &#x201c;conceptual states&#x201d; <i>readable</i> and <i>not readable</i>, <i>writable</i> and <i>not writable</i>. In PL/Java, an instance passed in as a parameter to a function, or retrieved from a <tt>ResultSet</tt>, is <i>readable</i> and <i>not writable</i>, and can be used as input to Java processing using any of the following methods:</p>

<dl>
<dt><tt>getBinaryStream()</tt></dt>
<dd>Obtain an <tt>InputStream</tt> with the raw, byte-stream-serialized XML, which will have to be passed to an XML parser. The parser will have to determine the encoding used from the declaration at the start of the stream, or assume UTF-8 if there is none, as the standard provides.</dd>
<dt><tt>getCharacterStream()</tt></dt>
<dd>Like <tt>getBinaryStream</tt> but as a stream of Java characters, with the underlying encoding already decoded. May be convenient for use with parsing code that isn&#x2019;t able to recognize and honor the encoding declaration, but any standard XML parser would work as well from <tt>getBinaryStream</tt>, which should be preferred when possible. A parser working from the binary stream is able to handle transcoding, if needed, in an XML-aware way. With this method, any needed transcoding is done without XML-awareness to produce the character stream.</dd>
<dt><tt>getString()</tt></dt>
<dd>Obtain the entire serialized XML value decoded as a Java <tt>String</tt>. Has the same memory footprint and encoding implications discussed for the legacy conversion to <tt>String</tt>, but may be convenient for some purposes or for values known to be small.</dd>
<dt><tt>getSource(javax.xml.transform.stream.StreamSource.class)</tt></dt>
<dd>Equivalent to one of the first two methods, but with the stream wrapped in a <tt>Source</tt> object, directly usable with Java XML transformation APIs.</dd>
<dt><tt>getSource(javax.xml.transform.sax.SAXSource.class)</tt></dt>
<dd>Obtain a <tt>Source</tt> object that presents the XML in parsed form via the SAX API, where the caller can register callback methods for XML constructs of interest, and then have Java stream through the XML value, calling those methods.</dd>
<dt><tt>getSource(javax.xml.transform.sax.StAXSource.class)</tt></dt>
<dd>Obtain a <tt>Source</tt> object that presents the XML in parsed form via the StAX API, where the value can be streamed through by calling StAX pull methods to get one XML construct at a time. Java code written to this API can more clearly reflect the expected structure of the XML document, compared to code written in the callback style for SAX.</dd>
<dt><tt>getSource(javax.xml.transform.sax.DOMSource.class)</tt></dt>
<dd>Obtain a <tt>Source</tt> object presenting the XML fully parsed as a navigable, in-memory DOM tree.</dd>
<dt><tt>getSource(null)</tt></dt>
<dd>Obtain a <tt>Source</tt> object of a type chosen by the implementation. Useful when the <tt>Source</tt> object will be passed to a standard Java transformation API, which can handle any of the above forms, letting the <tt>SQLXML</tt> implementation choose one that it implements efficiently.</dd>
</dl>
<p>Exactly one of these methods can be called exactly once on a <i>readable</i> <tt>SQLXML</tt> object, which is thereafter <i>not readable</i>. (The <i>not readable</i> state prevents a second call to any of the getter methods; it does not, of course, prevent reading the XML content through the one stream, <tt>String</tt>, or <tt>Source</tt> obtained from the getter method that was just called.)</p>
<p>Except in the <tt>String</tt> or DOM form, which bring the entire XML value into Java memory at once, the XML content is streamed directly from native PostgreSQL memory as Java code reads it, never accumulating in the Java heap unless that is what the application code does with it. Java heap sizing, therefore, can be based on just what the application Java code will do with the data.</p>
<p>The most convenient API to use in an application will often be SAX or StAX, in which the code can operate at the level of already-parsed, natural XML constructs. Code designed to work with a navigable DOM tree can easily obtain that form (but it should be understood that DOM will pull the entire content into Java memory at once, in a memory-hungry form that can easily be twenty times the size of the serialized value).</p>
<div class="section">
<h4><a name="Obtaining_a_readable_SQLXML_object"></a>Obtaining a <i>readable</i> <tt>SQLXML</tt> object</h4>
<p>To obtain a <i>readable</i> instance, declare <tt>java.sql.SQLXML</tt> as the type of a function parameter where PostgreSQL will pass an XML argument, or use the <tt>getSQLXML</tt> or <tt>getObject(..., SQLXML.class)</tt> methods on a <tt>ResultSet</tt>, or the <tt>readSQLXML</tt> or <tt>readObject(SQLXML.class)</tt> methods on <tt>SQLInput</tt>. A fully JDBC-4.0 compliant driver would also return <tt>SQLXML</tt> instances from the non-specific <tt>getObject</tt> and <tt>readObject</tt> methods, but in PL/Java, those have historically returned <tt>String</tt>. Because 1.5.1 is not a major release, their behavior has not changed, and the more-specific methods must be used to obtain <tt>SQLXML</tt> instances.</p></div></div>
<div class="section">
<h3><a name="Creatingreturning_a_PostgreSQL_XML_value_with_a_writable_SQLXML_object"></a>Creating/returning a PostgreSQL XML value with a <i>writable</i> <tt>SQLXML</tt> object</h3>
<p>PL/Java will supply an empty <tt>SQLXML</tt> instance that is <i>writable</i> and <i>not readable</i> via the <tt>Connection</tt> method <tt>createSQLXML()</tt>. It can be used as an output destination for any of several Java XML APIs, through a selection of <tt>set...</tt> methods exactly mirroring the available <tt>get...</tt> methods described above.</p>
<p><i>The API is unusual: except for <tt>setString</tt>, which takes a <tt>String</tt> parameter and returns <tt>void</tt> as a typical &#x201c;setter&#x201d; method would, the other setter methods are used for the object they return&#x2014;an <tt>OutputStream</tt>, <tt>Writer</tt>, or <tt>Result</tt>&#x2014;which the calling code should then use to add content to the XML value.</i></p>
<p>Exactly one setter method can be called exactly once on a <i>writable</i> <tt>SQLXML</tt> object, which is thereafter <i>not writable</i>. (The <i>not writable</i> state prevents a second call to any setter method; XML content must still be written via the stream or <tt>Result</tt> obtained from the one setter that was just called, except in the case of <tt>setString</tt>, which populates the value at once.) Content being written to the <tt>SQLXML</tt> object is accumulated in PostgreSQL native memory, not the Java heap.</p>
<p>A <tt>SQLXML</tt> object, once it has been fully written and closed, can be returned from a Java function, passed as a <tt>PreparedStatement</tt> parameter to a nested query, or stored into writable <tt>ResultSet</tt>s used for composite function or trigger results. It can be used exactly once in any of those ways, which transfer its ownership back to PostgreSQL, leaving it inaccessible from Java.</p>
<div class="section">
<h4><a name="When_a_writable_SQLXML_object_is_considered_closed"></a>When a <i>writable</i> <tt>SQLXML</tt> object is considered closed</h4>
<p>A <i>writable</i> <tt>SQLXML</tt> object cannot be presented to PostgreSQL before it is closed to confirm that writing is complete. (One written by <tt>setString</tt> is considered written, closed, and ready to use immediately.)</p>
<p>When it is written using a stream obtained from <tt>setBinaryStream</tt>, <tt>setCharacterStream</tt>, or <tt>setResult(javax.xml.transform.stream.StreamResult.class)</tt>, it is considered closed when the stream&#x2019;s <tt>close</tt> method is called. This will typically <i>not</i> be done by a Java <tt>Transformer</tt> with the stream as its result, and so should be explicitly called after such a transformation completes.</p>
<p>When written using a <tt>SAXResult</tt>, it is considered closed when the <tt>ContentHandler</tt>&#x2019;s <tt>endDocument</tt> method is called, and when written using a <tt>StAXResult</tt>, it is considered closed when the <tt>XMLStreamWriter</tt>&#x2019;s <tt>writeEndDocument</tt> method is called. When one of these flavors of <tt>Result</tt> is used with a Java <tt>Transformer</tt>, these methods will have been called in the normal course of the transformation, so nothing special needs to be done after the transformation completes.</p>
<p>What it means to <tt>close</tt> a <tt>DOMResult</tt> is murkier. The application code must call the <tt>DOMResult</tt>&#x2019;s <tt>setNode</tt> method, passing what will be the root node of the result document. This can be done before or after (or while) child nodes and content are added to that node. However, to avoid undefined behavior, application code must make no further modification to that DOM tree after the <tt>SQLXML</tt> object has been presented to PostgreSQL (whether via a <tt>PreparedStatement</tt> <tt>set</tt> method, <tt>ResultSet</tt> <tt>update</tt> method, <tt>SQLOutput</tt> <tt>write</tt> method, or returned as the function result).</p></div>
<div class="section">
<h4><a name="Using_a_Result_object_as_a_Transformer_result"></a>Using a <tt>Result</tt> object as a <tt>Transformer</tt> result</h4>
<p>Classes that extend <tt>javax.xml.transform.Transformer</tt> will generally accept any flavor of <tt>Result</tt> object and select the right API to write the transformation result to it. There is often no need to care which <tt>Result</tt> flavor to provide, so it is common to call <tt>setResult(null)</tt> to let the <tt>SQLXML</tt> implementation itself choose a flavor based on implementation-specific efficiency considerations.</p>
<p>In the case of a <tt>DOMResult</tt>, if the <tt>Result</tt> object is simply passed to a <tt>Transformer</tt> without calling <tt>setNode</tt> first, the <tt>Transformer</tt> itself will put an empty <tt>Document</tt> node there, which is then populated with the transformation results.</p>
<p>A <tt>Document</tt> node, however, enforces conformance to the strict rules of <tt>XML(DOCUMENT)</tt> form (described below). If the content to be written will conform only to the looser rules of <tt>XML(CONTENT)</tt> form, application code should call <tt>setNode</tt> supplying an empty <tt>DocumentFragment</tt> node, before passing the <tt>Result</tt> object to a <tt>Transformer</tt>.</p>
<p>The flavor of <tt>Result</tt> returned by <tt>setResult(null)</tt> will never (in PL/Java) be <tt>DOMResult</tt>.</p></div></div>
<div class="section">
<h3><a name="Using_an_unread_readable_SQLXML_object_as_a_written_one"></a>Using an unread <i>readable</i> <tt>SQLXML</tt> object as a written one</h3>
<p>The general rule that only a <i>writable</i> instance (that has been written and closed) can be used as a function result, or passed into a nested query, admits one exception, allowing a <i>readable</i> instance that Java code has obtained but not read. That makes it simple for Java code to obtain an <tt>SQLXML</tt> instance passed in as a parameter, or from a query, and use it directly as a result or a nested-query parameter. Any one instance can be used this way no more than once.</p></div>
<div class="section">
<h3><a name="XMLDOCUMENT_and_XMLCONTENT"></a><tt>XML(DOCUMENT)</tt> and <tt>XML(CONTENT)</tt></h3>
<p>An XML value in SQL can have the type <tt>XML(DOCUMENT)</tt> or <tt>XML(CONTENT)</tt> (as those are defined in the ISO SQL standard, 2006 and later), which PostgreSQL does not currently treat as distinguishable types. The <tt>DOCUMENT</tt> form must have exactly one root element, may have a document-type declaration (DTD), and has strict limits on where other constructs (other than comments and processing instructions) can occur. A value in <tt>CONTENT</tt> form may have no root element, or more than one element at top level, and other constructs such as character data outside of a root element where <tt>DOCUMENT</tt> form would not allow them.</p>
<div class="section">
<h4><a name="How_both_forms_are_accommodated_when_reading"></a>How both forms are accommodated when reading</h4>
<p>Java code using a <i>readable</i> <tt>SQLXML</tt> instance as input should be prepared to encounter either form (unless it has out-of-band knowledge of which form will be supplied). If it requests a <tt>DOMSource</tt>, <tt>getNode()</tt> will return a <tt>Document</tt> node, if the value met all the requirements for <tt>DOCUMENT</tt>, or a <tt>DocumentFragment</tt> node, if it was parsable as <tt>CONTENT</tt>. Java code requesting a <tt>SAXSource</tt> or <tt>StAXSource</tt> should be prepared to handle a sequence of constructs that might not be encountered when parsing a strictly conforming <tt>DOCUMENT</tt>. Java code that requests an <tt>InputStream</tt>, <tt>Reader</tt>, <tt>String</tt>, or <tt>StreamSource</tt> will be on its own to parse the data in whichever form appears.</p></div>
<div class="section">
<h4><a name="How_both_forms_are_accommodated_when_writing"></a>How both forms are accommodated when writing</h4>
<p>Java code using a <i>writable</i> SQLXML instance to produce a result may write either <tt>DOCUMENT</tt> or <tt>CONTENT</tt> form. If using <tt>DOMResult</tt>, it must supply a <tt>DocumentFragment</tt> node to produce a <tt>CONTENT</tt> result, as a <tt>Document</tt> node will enforce the <tt>DOCUMENT</tt> requirements.</p></div></div>
<div class="section">
<h3><a name="An_SQLXML_object_has_transaction_lifetime"></a>An <tt>SQLXML</tt> object has transaction lifetime</h3>
<p>The JDBC spec provides that an <tt>SQLXML</tt> instance is &#x201c;valid for the duration of the transaction in which it was created.&#x201d; One PL/Java function can hold an <tt>SQLXML</tt> instance (in a static or session variable or data structure), and other PL/Java functions called later in the same transaction can continue reading from or writing to it. If the transaction has committed or rolled back, those operations will generate an exception.</p>
<p>Once a <i>writable</i> <tt>SQLXML</tt> object, or an unread, <i>readable</i> one, has been presented to PostgreSQL as the result of a PL/Java function or through a <tt>PreparedStatement</tt>/<tt>ResultSet</tt>/<tt>SQLOutput</tt> setter method, it is no longer accessible in Java.</p>
<p>During a transaction, resources held by a <tt>SQLXML</tt> object are reclaimed as soon as a <i>readable</i> one has been fully read, or a <i>writable</i> one has been presented to PostgreSQL and PostgreSQL is done with it. If application code holds a readable <tt>SQLXML</tt> object that it determines it will not read, or a writable one it will not present to PostgreSQL, it can call the <tt>free</tt> method to allow the resources to be reclaimed sooner than the transaction&#x2019;s end.</p></div>
<div class="section">
<h3><a name="Lazy_detoasting"></a>Lazy detoasting</h3>
<p>PostgreSQL can represent large XML values in &#x201c;TOASTed&#x201d; form, which may be in memory but compressed (XML typically compresses to a small fraction of its serialized size), or may be a small pointer to a location in storage. A <i>readable</i> <tt>SQLXML</tt> instance over a TOASTed value will not be detoasted until Java code actually begins to read it, so the memory footprint of an instance being held but not yet read is kept low.</p></div>
<div class="section">
<h3><a name="Validation_of_content"></a>Validation of content</h3>
<p>Some of the methods by which a <i>writable</i> instance can be written are not XML-specific APIs, but allow arbitrary content to be written (as a <tt>String</tt>, <tt>Writer</tt>, or <tt>OutputStream</tt>). When written by those methods, type safety is upheld by verifying that the written content can be successfully reparsed, accepting either <tt>DOCUMENT</tt> or <tt>CONTENT</tt> form.</p>
<p>It remains possible to declare the Java type <tt>String</tt> for function parameters and returns of XML type, and to retrieve and supply <tt>String</tt> for <tt>ResultSet</tt> columns and <tt>PreparedStatement</tt> parameters of XML type. This legacy mapping from <tt>String</tt> to XML uses PostgreSQL&#x2019;s <tt>xml_in</tt> function to verify the form of a <tt>String</tt> from Java. That function may reject some valid values if the server configuration variable <tt>xmloption</tt> is not first set to <tt>DOCUMENT</tt> or <tt>CONTENT</tt> to match the type of the value.</p></div>
<div class="section">
<h3><a name="Usable_with_or_without_native_XML_support_in_PostgreSQL"></a>Usable with or without native XML support in PostgreSQL</h3>
<p>In symmetry to using Java <tt>String</tt> for SQL XML types, PL/Java allows the Java <tt>SQLXML</tt> type to be used with PostgreSQL data of type <tt>text</tt>. This allows full use of the Java XML APIs even in PostgreSQL instances built without XML support. All of the <tt>SQLXML</tt> behaviors described above also apply in this usage.</p>
<p>If a <i>readable</i> <tt>SQLXML</tt> instance obtained from a <tt>text</tt> value is directly used to set or return a value of PostgreSQL&#x2019;s XML type, the XML-ness of the content is verified.</p></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2003&#x2013;2018
                        <a href="http://tada.se/eng/">Tada AB</a>.
            All rights reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
